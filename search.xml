<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[spring基于注解开发]]></title>
    <url>%2F2019%2F03%2F03%2Fspring%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[spring基于注解开发一、bean的加载1.@Configuration，@Bean12345678910@Configurationpublic class Config&#123; @Bean("person") public Person personA() &#123; Person a =new Person(10,"jerry"); return a; &#125;&#125; 测试： 123456public static void main(String[] args)&#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Config.class); Person person = applicationContext.getBean("person", Person.class); System.out.println(person);&#125; @Bean 注解默认采用方法名作为bean的名字，也可以指定bean名。 2.@ComponentScan、@Component、@Service等1234@ComponentScan(basePackages = "com.tiger")public class Config&#123;&#125; 12345@Componentpublic class Person&#123; &#125; 12345@Servicepublic class PersonService&#123;&#125; 测试: 12345678910111213@Testpublic void test1()&#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext( Config.class); String[] beanDefinitionNames = context.getBeanDefinitionNames(); for(String beanName:beanDefinitionNames) &#123; System.out.println(beanName); &#125;&#125; 结果: 123456789org.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactoryconfigpersonpersonDaopersonService 可以通过excludeFilters参数来限制扫描的范围。例如12@ComponentScan(basePackages = &quot;com.tiger&quot;, excludeFilters = &#123; @Filter(type = FilterType.ANNOTATION,classes = &#123; Controller.class&#125;) &#125;) 值得一提的是@ComponentScan里的一个字段boolean useDefaultFilters() default true;默认为true，也就是默认会加载指定包下的所有bean，如果只想指定的bean被加载，应设定为false，此时通过includeFilters来指定需要加载的bean才会生效，如下 1234567@ComponentScan(basePackages = "com.tiger", includeFilters = &#123; @Filter(type = FilterType.ANNOTATION, classes = &#123; Service.class &#125;), @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = &#123; Person.class &#125;) &#125;,useDefaultFilters = false)public class Config&#123;&#125; 还可以定制化Filter来过滤需要加载的bean，如下 1234567891011121314public class MyFilter implements TypeFilter&#123; public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; ClassMetadata classMetadata = metadataReader.getClassMetadata(); String className = classMetadata.getClassName(); if(className.contains("Dao")) &#123; return true; &#125; return false; &#125;&#125; 1234567@ComponentScan(basePackages = "com.tiger", includeFilters = &#123; @Filter(type = FilterType.CUSTOM,classes = MyFilter.class)&#125;,useDefaultFilters = false)public class Config&#123;&#125; 这样包含”Dao”字符串的类才会被spring容器加载。 3.@Scope、@Lazy常用的 @Scope(&quot;singleton&quot;) 该bean在spring容器中为单例，每次取bean都是同一个，而且该bean在spring容器启动的时候就会被实例化 @Scope(&quot;prototype&quot;) 每次获取bean都是重新实例化。 @Lazy如果bean的作用域为单例，而且不希望在spring容器刚启动时就被加载，可以用此注解，这样只有在获取该bean时才会被实例化。 4.@Conditional可以通过该注解来决定当前的bean是否应该被加载到spring容器，比如以下的两个bean，希望在Windows环境下加载”bill”这个bean，而在“linux”环境下加载‘’linas‘这个bean，代码如下 12345678910111213@Conditional(WindowCondition.class)@Bean("bill")public Person person()&#123; return new Person(19,"bill Gates");&#125;@Conditional(LinuxCondition.class)@Bean("linas")public Person person2()&#123; return new Person(20,"linas");&#125; WindowCondition类实现Condition接口，在实现方法中来判断环境 1234567891011121314public class WindowCondition implements Condition&#123; public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; Environment environment = context.getEnvironment(); //这里可以通过context、metadata参数实现多样的判断条件 if(environment.getProperty("os.name").contains("Windows")) &#123; return true; &#125; return false; &#125;&#125; 5.@import在配置类上通过@Import注解也可以加载bean 直接指定需要加载的类 12345@Configuration@Import(Apple.class)public class Config &#123;&#125; 通过实现ImportSelector接口，来指定需要加载的bean，如下 123456public class MySelector implements ImportSelector &#123; @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; return new String[]&#123;"com.example.demo.bean.Apple", "com.example.demo.controller.TestController"&#125;; &#125;&#125; 12345@Configuration@Import(MySelector.class)public class Config &#123;&#125; 通过实现ImportBeanDefinitionRegistrar接口来实现加载bean，例如如果有名为apple的bean就加载TestControllerbean 123456789101112public class MyImportBeanDefinitionRegister implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; String[] beanDefinitionNames = registry.getBeanDefinitionNames(); for (String beanName : beanDefinitionNames) &#123; if (beanName.contains("apple")) &#123; RootBeanDefinition testConDef = new RootBeanDefinition(TestController.class); registry.registerBeanDefinition("testController",testConDef); &#125; &#125; &#125;&#125; 123456789@Configuration@Import(MyImportBeanDefinitionRegister.class)public class Config &#123; @Bean("apple") public Apple apple() &#123; return new Apple(); &#125;&#125; 6.通过工厂类来装配bean，可以实现FactoryBean接口来注入bean123456789101112131415@Componentpublic class AppleFactory implements FactoryBean&lt;Apple&gt; &#123; @Override public Apple getObject() throws Exception &#123; return new Apple(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return Apple.class; &#125; @Override public boolean isSingleton() &#123; return true; &#125;&#125; 该bean在spring容器里的名称为appleFactory，但是通过获取该bean的实际类型，可以发现为Apple，如果需要获取AppleFactory本身的bean的话，可以在名称前加&amp;,如applicationContext.getBean(&quot;&amp;appleFactory&quot;); 123Object apple = applicationContext.getBean("appleFactory");System.out.println(apple.getClass());//打印内容:class com.example.demo.bean.Apple 7.bean加载总结给容器中注册bean，有如下四种方式 包扫描@ComponentScan，结合@Component相关注解 @Configuration和@Bean相结合，可以用来注册第三方包里面的bean @Import方式，可以添加相关注解属性来决定需要加载的bean 工程类，通过实现FactoryBean接口 二、bean的生命周期1.指定@Bean初始化和销毁方法Apple Bean中增加两个方法 1234567public void init() &#123; System.out.println("Apple init");&#125;public void destroy() &#123; System.out.println("Apple destroy");&#125; 在配置类中的@Bean增加两个字段 1234@Bean(value = "apple1",initMethod = "init",destroyMethod = "destroy")public Apple apple() &#123; return new Apple("jerry", 18);&#125; 启动spring容器后，再关闭容器，输出结果如下 1234Apple 实例化Apple init22:51:45.503 [main] DEBUG org.springframework.context.annotation.AnnotationConfigApplicationContext - Closing Apple destroy 可知，在bean创建完成，并赋值好后，会执行initMethod，在spring容器关闭后会执行destroyMethod,另外，在多实例场景下，之后获取该bean时才会执行initMethod,而容器关闭时不会执行destroyMethod 2.实现InitializingBean, DisposableBean接口，重写接口方法即可3.通过注解@PostConstruct和@PreDestroy,如下代码12345678910111213141516171819202122public class Apple implements InitializingBean, DisposableBean &#123;@Overridepublic void afterPropertiesSet() throws Exception &#123; System.out.println("初始化完成");&#125;@Overridepublic void destroy() throws Exception &#123; System.out.println("销毁");&#125;@PostConstructpublic void postConstruct() &#123; System.out.println("@PostConstruct");&#125;@PreDestroypublic void preDestroy() &#123; System.out.println("@preDestroy");&#125;&#125; 输出结果为 123456Apple 实例化@PostConstruct初始化完成org.springframework.context.annotation.AnnotationConfigApplicationContext - Closing @preDestroy销毁 todo…]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven中如何解决jar包冲突]]></title>
    <url>%2F2019%2F02%2F18%2FMaven%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3jar%E5%8C%85%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[现象程序启动运行时报出类似如下的错误 12Caused by:java.lang.NoSuchMethodErrorCaused by: java.lang.ClassNotFoundException 原因 假设当前工程A依赖B和C，而B依赖D(version=1.1),C依赖D(version=1.2)，Maven根据依赖的最短路径原则可能A工程最终引用到的jar包来自于工程B，C，D(version=1.1)，而我们A代码中调用的某个方法来自于高版本的D(version=1.2)，所以会出现以上类型的错误。 解决思路 根据报错信息，确定出现问题的jar包，idea中可以通过全局搜索类文件(ctrl+shift+n)，再定位jar包。 分析项目中要使用的jar包到底是哪一个 通过mvn dependency:tree &gt; tree.txt导出当前maven工程所依赖的jar包树结构 定位到需要去除的jar包的父模块，通过&lt;exclusions&gt;来进行排除]]></content>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务基础梳理]]></title>
    <url>%2F2019%2F02%2F08%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[微服务架构的特点 微服务带来的利弊]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[到底什么是微服务]]></title>
    <url>%2F2019%2F01%2F26%2F%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[我们先来看看维基百科是如何定义微服务的。微服务的概念最早是在 2014 年由 Martin Fowler 和 James Lewis 共同提出，他们定义了微服务是由单一应用程序构成的小服务，拥有自己的进程与轻 量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通讯。同时， 服务会使用最小规模的集中管理（例如 Docker）技术，服务可以用不同的编程语言与数据库等。 这个理论的定义看着有点晕？没关系，接下来我来帮你理解到底什么是微服务？ 单体应用在开聊微服务之前，我先要你和介绍下单体应用。如果你不知道单体应用的痛，那也不会深刻理解 微服务的价值。 早些年，各大互联网公司的应用技术栈大致可分为 LAMP（Linux + Apache + MySQL + PHP）和 MVC（Spring + iBatis/Hibernate + Tomcat ）两大流派。无论是 LAMP 还是 MVC，都是为单体应 用架构设计的，其优点是学习成本低，开发上手快，测试、部署、运维也比较方便，甚至一个人就 可以完成一个网站的开发与部署。 以 MVC 架构为例，业务通常是通过部署一个 WAR 包到 Tomcat 中，然后启动 Tomcat ，监听某个端口即可对外提供服务。早期在业务规模不大、开发团队人员规模较小的时候，采用单体应用架 构，团队的开发和运维成本都可控。 然而随着业务规模的不断扩大，团队开发人员的不断扩张，单体应用架构就会开始出现问题。我估 计经历过业务和团队快速增长的同学都会对此深有感触。从我的角度来看，大概会有以下几个方面 的问题。 部署效率低下。以我实际参与的项目为例，当单体应用的代码越来越多，依赖的资源越来越多 时，应用编译打包、部署测试一次，甚至需要 10 分钟以上。这也经常被新加入的同学吐槽说， 部署测试一次的时间，都可以去楼下喝杯咖啡了。 团队协作开发成本高。以我的经验，早期在团队开发人员只有两三个人的时候，协作修改代码， 最后合并到同一个 master 分支，然后打包部署，尚且可控。但是一旦团队人员扩张，超过 5 人 修改代码，然后一起打包部署，测试阶段只要有一块功能有问题，就得重新编译打包部署，然后 重新预览测试，所有相关的开发人员又都得参与其中，效率低下，开发成本极高。 系统高可用性差。因为所有的功能开发最后都部署到同一个 WAR 包里，运行在同一个 Tomcat 进程之中，一旦某一功能涉及的代码或者资源有问题，那就会影响整个 WAR 包中部署的功能。 比如我经常遇到的一个问题，某段代码不断在内存中创建大对象，并且没有回收，部署到线上运 行一段时间后，就会造成 JVM 内存泄露，异常退出，那么部署在同一个 JVM 进程中的所有服务 都不可用，后果十分严重。 线上发布变慢。特别是对于 Java 应用来说，一旦代码膨胀，服务启动的时间就会变长，有些甚 至超过 10 分钟以上，如果机器规模超过 100 台以上，假设每次发布的步长为 10%，单次发布需 要就需要 100 分钟之久。因此，急需一种方法能够将应用的不同模块的解耦，降低开发和部署成 本。 想要解决上面这些问题，服务化的思想也就应运而生。 什么是服务化？这里我就不谈一些官方的、教条主义的概念了。在我看来，用通俗的话来讲，服务化就是把传统的 单机应用中通过 JAR 包依赖产生的本地方法调用，改造成通过 RPC 接口产生的远程方法调用。一 般在编写业务代码时，对于一些通用的业务逻辑，我会尽力把它抽象并独立成为专门的模块，因为 这对于代码复用和业务理解都大有裨益。 在过去的项目经历里，我对此深有体会。以微博系统为例，微博既包含了内容模块，也包含了消息 模块和用户模块等。其中消息模块依赖内容模块，消息模块和内容模块又都依赖用户模块。当这三 个模块的代码耦合在一起，应用启动时，需要同时去加载每个模块的代码并连接对应的资源。一旦 任何模块的代码出现 bug，或者依赖的资源出现问题，整个单体应用都会受到影响。 为此，首先可以把用户模块从单体应用中拆分出来，独立成一个服务部署，以 RPC 接口的形式对外 提供服务。微博和消息模块调用用户接口，就从进程内的调用变成远程 RPC 调用。这样，用户模块 就可以独立开发、测试、上线和运维，可以交由专门的团队来做，与主模块不耦合。进一步的可以 再把消息模块也拆分出来作为独立的模块，交由专门的团队来开发和维护。 可见通过服务化，可以解决单体应用膨胀、团队开发耦合度高、协作效率低下的问题。 什么是微服务？从 2014 年开始，得益于以 Docker 为代表的容器化技术的成熟以及 DevOps 文化的兴起，服务化 的思想进一步演化，演变为今天我们所熟知的微服务。 那么微服务相比于服务化又有什么不同呢？ 在我看来，可以总结为以下四点： 服务拆分粒度更细。微服务可以说是更细维度的服务化，小到一个子模块，只要该模块依赖的资 源与其他模块都没有关系，那么就可以拆分为一个微服务。 服务独立部署。每个微服务都严格遵循独立打包部署的准则，互不影响。比如一台物理机上可以 部署多个 Docker 实例，每个 Docker 实例可以部署一个微服务的代码。 服务独立维护。每个微服务都可以交由一个小团队甚至个人来开发、测试、发布和运维，并对整 个生命周期负责。 服务治理能力要求高。因为拆分为微服务之后，服务的数量变多，因此需要有统一的服务治理平台，来对各个服务进行管理。 继续以前面举的微博系统为例，可以进一步对内容模块的功能进行拆分，比如内容模块又包含了 feed 模块、评论模块和个人页模块。通过微服务化，将这三个模块变成三个独立的服务，每个服务 依赖各自的资源，并独立部署在不同的服务池中，可以由不同的开发人员进行维护。当评论服务需 求变更时，只需要修改评论业务相关的代码，并独立上线发布；而 feed 服务和个人页服务不需要 变更，也不会受到发布可能带来的变更影响。 由此可见，微服务化给服务的发布和部署，以及服务的保障带来了诸多好处。 总结今天，我介绍了微服务的发展由来，它是由单体应用进化到服务化拆分部署，后期随着移动互联网 规模的不断扩大，敏捷开发、持续交付、DevOps 理论的发展和实践，以及基于 Docker 容器化技 术的成熟，微服务架构开始流行，逐渐成为应用架构的未来演进方向。 总结来说，微服务架构是将复杂臃肿的单体应用进行细粒度的服务化拆分，每个拆分出来的服务各自独立打包部署，并交由小团队进行开发和运维，从而极大地提高了应用交付的周期，并被各大互 联网公司所普遍采用。 END 转自《极客时间》]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Config入门]]></title>
    <url>%2F2019%2F01%2F07%2FSpring-Cloud-Config%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[概述随着微服务的流行，原来的单体应用逐渐拆解成一个个的微服务，与此带来的一个问题就是每一个微服务都有对应的一个配置文件，如application.properties或application.yml文件，一旦微服务应用达到几十个甚至更多时，修改配置文件估计不是一个轻松的活，Spring Cloud Config就是来解决这个问题的，它为分布式系统中的基础设施和微服务应用提供集中化的配置支持，分为服务端和客户端两个部分，其中服务端即配置中心会连接配置仓库(默认为git服务器)来获取配置信息，向客户端提供配置信息。由于采用git来存储配置数据，所以天然支持微服务配置的版本管理功能。 入门基础模块搭建新建一个公共基础模块，服务端和客户端在此基础上添加module，依赖如下 1234567891011121314151617181920212223242526272829303132&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;&lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 管理依赖 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 服务端搭建 step1:新建一个config-server工程module，依赖如下 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件信息如下 123456789spring: cloud: config: server: git: uri: https://github.com/tigeryj/spring-cloud-config search-paths: SC-BOOK-CONFIGserver: port: 9090 因为仓库设置为public所以配置文件中不需要配置git的用户名和密码。search-paths表示查找配置文件时会从该目录下搜索，服务运行在9090端口。 step2: 在github上新建了一个仓库spring-cloud-config,在SC-BOOK-CONFIG目录下放置一个配置文件config-info-prod.yml，文件的内容如下 1234cn: springcloud: book: config: I am the git configuration file dev 最后一次测试2222... 其中config-info为服务application，prod表示生产环境，还有lable表示当前文件在git的分支，配置中心可以通过这三个参数来从git服务器上定位自己所需要的配置文件。 step3:配置服务器启动，主要添加@EnableConfigServer注解 12345678@SpringBootApplication@EnableConfigServerpublic class ConfigGitApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigGitApplication.class,args); &#125;&#125; 至此，配置中心搭建完成，启动服务器，通过get方式访问 http://localhost:9090/master/config-info-prod.yml 以上可以看到通过配置服务中心可以查询到git服务器上的数据，注意URL中的查询参数是/{application}/{profile}[/{lable}].当然也可以通过以下格式查询 /{application}-{profile}.yml /{lable}/{application}-{profile}.yml /{application}-{profile}.properties /{lable}/{application}-{profile}.properties 其中application代表应用名称(服务名)，profile代表环境类型，lable代表分支名称。 客户端搭建 step1:在父工程目录下创建一个module，命名为config-client，pom文件的依赖如下: 1234567891011121314151617181920212223&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--做简单的安全和短点开放 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; step2: 创建SpringBoot应用主类，和相关的配置文件 123456@SpringBootApplicationpublic class ClientConfigGitApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ClientConfigGitApplication.class,args); &#125;&#125; 12345678# bootstrap.yml文件spring: cloud: config: label: master uri: http://localhost:9090 name: config-info profile: prod 需要注意的是，必须要在bootstrap.yml配置文件中指定config-server的位置，其加载顺序在application.yml配置文件之前，这样才使客户端获取到server端的数据，这些数据的优先级比本地的内容要高，从而实现了外部化配置。 step3:创建一个bean来获取server端配置 123456789101112@Component@RefreshScopepublic class ConfigInfoProperties &#123; @Value("$&#123;cn.springcloud.book.config&#125;") private String config; public String getConfig() &#123; return config; &#125; public void setConfig(String config) &#123; this.config = config; &#125;&#125; step4：启动服务端和客户端，并通过一个rest接口来测试是否能够访问到server端的数据 12345678910@RefreshScope@RestControllerpublic class ConfigClientController &#123; @Autowired private ConfigInfoProperties configInfoValue; @RequestMapping("/getConfigInfo") public String getConfigInfo() &#123; return configInfoValue.getConfig(); &#125;&#125; 访问客户端的端口号，http://localhost:9091/getConfigInfo，返回如下 可以发现与git中的数据一致，说明客户端通过服务端查询到了自己需要的配置信息，这样客户端也就是微服务的配置数据可以放到配置中心服务端统一管理。 END 工程代码github]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8特性(二)]]></title>
    <url>%2F2019%2F01%2F01%2Fjava8%E7%89%B9%E6%80%A72%2F</url>
    <content type="text"><![CDATA[一.从函数表达式到方法引用前一篇文章中，小明采用Lambda表达式将行为参数化，从而将挑选苹果的条件和挑选苹果的方法解耦，现在来演进一下文章一开始抛出的问题，即用不同的排序策略来将Apple列表进行排序。 step1: 已有一个List，目的是按照一定的规则对其排序，List类中有一个sort方法，如下： 1void sort(Comparator&lt;? super E&gt; c) 很明显，我们只需要传入一个Comparator的接口实现类即可，该类包裹了我们的排序策略，即将行为通过对象的方式达到“行为参数化”，如下： 123456public class AppleComparator implements Comparator&lt;Apple&gt; &#123; public int compare(Apple a1, Apple a2) &#123; return a1.getWeight().compareTo(a2.getWeight()); &#125;&#125;inventory.sort(new AppleComparator()); step2: 后来有了匿名内部类，代码改为如下： 12345inventory.sort(new Comparator&lt;Apple&gt;()&#123; public int compare (Apple a1, Apple a2)&#123; return a1.getWeight().compareTo(a2.getWeight()); &#125;&#125;); step3: java8有了Lambda表达式后，演化成如下： 1inventory.sort((Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()) ); 在Comparator中有个静态方法comparing静态辅助方法，会返回一个Comparator对象，参数是Function，代码如下： 12import static java.util.Comparator.comparing;inventory.sort(comparing((a) -&gt; a.getWeight())); step4: 使用方法引用语法糖来代替Lambda表达式，得到最后的演化结果： 1inventory.sort(comparing(Apple::getWeight);]]></content>
      <categories>
        <category>JAVA语言</category>
      </categories>
      <tags>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8特性(一)]]></title>
    <url>%2F2018%2F12%2F07%2Fjava8%E7%89%B9%E6%80%A71%2F</url>
    <content type="text"><![CDATA[一.为什么要学java8？ 代码表达能力更强，风格更简约。比如：对一个仓库里的苹果按重量进行排序，java8之前的代码可能是这样 12345Collections.sort(inventory, new Comparator&lt;Apple&gt;() &#123; public int compare(Apple a1, Apple a2)&#123; return a1.getWeight().compareTo(a2.getWeight()); &#125;&#125;); 而在java8里是这样的 1inventory.sort(comparing(Apple::getWeight)); 很明显，后者代码表达的更准确，以后也更容易维护。这种将函数传递给方法的方式，我们称之为函数式编程，也叫行为参数化，用更高级的一种方式来表达我们想要的东西。 代码效率更高、支持安全的并行执行。java8里的流实现并行，要比现有的有关线程安全的api实现的更容易。但是你的代码行为必须能够同时的对不同的输入安全的执行。 二.开始函数式编程之路小明是一个水果贩子，手里拿着一个List&lt;Apple&gt; inventory,客户想要这里面所有的绿苹果，而小明可能会实现如下代码： 123456789public static List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; inventory) &#123; List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;(); for(Apple apple: inventory)&#123; //累积苹果的列表 if( "green".equals(apple.getColor() ) &#123; result.add(apple); //仅仅选出绿苹果 &#125; &#125; return result;&#125; 这是最直觉的思考方式下的结果，可当小明把全部的绿苹果打包完毕后，客户突然冒出一句，“红苹果也不错，我还是要所有的红苹果吧?”，小明气不打一处来，把上面的”green”换成”red”之后，当天晚上就加班搞了另外一个方法，才安然入睡 123456789public static List&lt;Apple&gt; filterApplesByColor(List&lt;Apple&gt; inventory, String color) &#123; List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;(); for (Apple apple : inventory) &#123; if (apple.getColor().equals(color)) &#123; result.add(apple); &#125; &#125; return result; &#125; 但是，突然有一天，小明又接到一个电话，对方说要3两以上的苹果，机智的小明实现了如下代码: 123456789public static List&lt;Apple&gt; filterApplesByWeight(List&lt;Apple&gt; inventory, int weight) &#123; List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;(); For(Apple apple:inventory)&#123; if (apple.getWeight() &gt; weight) &#123; result.add(apple); &#125; &#125; return result; &#125; 但是小明发现，每次客户变化一个需求，就要重新搞一套方法，而且这里面的方法好多代码都是重复的，除了if里面的判断语句不一样而已。而且为了筛选苹果的方法和具体的筛选条件进行解耦，小明写了个接口，以后再有具体的筛选条件，就实现这个接口就可以了。如下 1234567891011121314public interface ApplePredicate &#123; boolean test(Apple apple); &#125;public class AppleHeavyWeightPredicate implements ApplePredicate &#123; public boolean test(Apple apple) &#123; return apple.getWeight() &gt; 150; &#125; &#125;public class AppleGreenColorPredicate implements ApplePredicate &#123; public boolean test(Apple apple) &#123; return "green".equals(apple.getColor()); &#125; &#125; 之后小明的挑选苹果的方法编程如下代码 123456789public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; inventory, ApplePredicate p) &#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) &#123; if (p.test(apple)) &#123; result.add(apple); &#125; &#125; return result; &#125; 从此以后，挑选苹果的方法和挑选苹果的条件就实现了解耦。小明松了一口气，对外宣称这就是我们的『行为参数化』，你看多方便，客户来一个条件，我就按照这个条件实现ApplePredicate接口，在里面写具体的业务逻辑，但是，随着客户的需求不断增多，小明发现，每次都需要新建一个类来包裹那里面一个test方法，说到底，不就是要一个test方法么。有没有更简单的方法呢？突然小明脑海中闪现出一个名词:匿名内部类 12345List&lt;Apple&gt; redApples = filterApples(inventory, new ApplePredicate() &#123; public boolean test(Apple apple) &#123; return "red".equals(apple.getColor()); &#125; &#125;); 就在小明用匿名内部类来传递自己筛选苹果的条件代码，用的热火朝天之际，java8的Lambda表达式突然宣告诞生，小明欣喜的跟上了时代的步伐: 1List&lt;Apple&gt; result = filterApples(inventory, (Apple apple) -&gt; "red".equals(apple.getColor())); 他突然感悟到所谓的大道至简是有点道理的。随着小明卖苹果的技术越来越精湛、效率越来越高，很快也开始主营卖香蕉、菠萝，聪明的小明一下子就明白，把原来的卖苹果那一套进一步抽象，适合卖所有的水果: 123456789101112public interface Predicate&lt;T&gt; &#123; boolean test(T t); &#125;public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p) &#123; List&lt;T&gt; result = new ArrayList&lt;&gt;(); for (T e : list) &#123; if (p.test(e)) &#123; result.add(e); &#125; &#125; return result;&#125; 这样，小明平常就是这样经营他的水果摊的 12List&lt;Apple&gt; redApples = filter(inventory, (Apple apple) -&gt; "red".equals(apple.getColor()));List&lt;Orange&gt; heavyOranges=filter(inventory,(Orange o)-&gt; o.getWeight&gt;30); 这里Predicate，可以称之为函数式接口，其实它已经存在于java.util.function包中了。以后可以直接拿来用，爽歪歪有木有？只要该接口只包含一个抽象方法即可。函数式接口可以方便你写出Lambda表达式 下图为java8中典型的函数式接口]]></content>
      <categories>
        <category>JAVA语言</category>
      </categories>
      <tags>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架问题]]></title>
    <url>%2F2017%2F07%2F03%2F%E6%A1%86%E6%9E%B6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、什么是Spring框架？Spring框架有哪些主要模块？Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。 2、使用Spring框架能带来哪些好处？ 使用IoC容器可以更加容易组合对象直接间接关系，面向接口编程，降低耦合。 AOP可以更加容易的进行功能扩展，如安全、事务、日志等。 spring的orm和DAO提供了与第三方持久层框架的良好整合。 3、什么是控制反转(IOC)？什么是依赖注入？控制反转意味着将设计好的对象交给容器控制，而不是传统的在对象内部直接控制，Ioc和AOP是同一个概念从不同角度的描述。依赖注入的三种方法1.构造器注入 2.setter方法注入3.接口注入 4、BeanFactory和ApplicationContext有什么区别？BeanFactory 可以理解为含有bean集合的工厂类。BeanFactory 包含了种bean的定义，以便在接收到客户端请求时将对应的bean实例化。BeanFactory还包含了bean生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。ApplicationContext包还提供了以下的功能： 利用MessageSource进行国际化 强大的事件机制(Event) 底层资源的访问 ApplicationContext扩展了ResourceLoader(资源加载器)接口，从而可以用来加载多个Resource，而BeanFactory是没有扩展ResourceLoader BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化，这样，我们就不能发现一些存在的spring的配置问题。而ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误。 5.Spring有几种配置方式？将Spring配置到应用开发中有以下三种方式：基于XML的配置、基于注解的配置、基于Java的配置 6、如何用基于Java配置的方式配置Spring？Spring对Java配置的支持是由@Configuration注解和@Bean注解来实现的。由@Bean注解的方法将会实例化、配置和初始化一个新对象，这个对象将由Spring的IoC容器来管理。@Bean声明所起到的作用与 元素类似。被@Configuration所注解的类则表示这个类的主要目的是作为bean定义的资源。被@Configuration声明的类可以通过在同一个类的内部调用@bean方法来设置嵌入bean的依赖关系。 7.请解释Spring Bean的生命周期？（看）Spring框架提供了以下四种方式来管理bean的生命周期事件： InitializingBean和DisposableBean回调接口 针对特殊行为的其他Aware接口 Bean配置文件中的Custom init()方法和destroy()方法 @PostConstruct和@PreDestroy注解方式 8.Spring Bean的作用域之间有什么区别？ singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。 prototype：原形范围与单例范围相反，为每一个bean请求提供一个实例。 request：在请求bean范围内会为每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。 Session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。 global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。 9.什么是Spring inner beans？在Spring框架中，无论何时bean被使用时，当仅被调用了一个属性。一个明智的做法是将这个bean声明为内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现。比如，在我们的应用程序中，一个Customer类引用了一个Person类，我们的要做的是创建一个Person的实例，然后在Customer内部使用。 10.Spring框架中的单例Beans是线程安全的么？Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Service类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。 11.请解释Spring Bean的自动装配？ 1.在XML配置文件实现自动装配 根据名称自动装配（byName）。因为spring 容器中Bean的名称是唯一的，所以不会产生歧义，推荐使用这种方式。 根据类型自动装配（byType）。在Spring容器中可能会找到多个跟需要注入的bean的类型相同的Bean，所以会产生歧义，Spring容器不知道注入哪个Bean，这时会抛出异常。 根据构造器自动装配（constructor）。这种方式比较复杂，不做分析。 2.使用注解实现自动装配 修改User.java文件和XML配置文件就行了。 使用@Autowired注解，和配置文件中加入context:annotation-config/ 12.请解释自动装配模式的区别？ no：这是Spring框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在bean定义中用标签明确的设置依赖关系。 byName：该选项可以根据bean名称设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的名称自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。 byType：该选项可以根据bean类型设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的类型自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。 constructor：造器的自动装配和byType模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。 autodetect：该模式自动探测使用构造器自动装配或者byType自动装配。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在bean内部没有找到相应的构造器或者是无参构造器，容器就会自动选择byTpe的自动装配方式。 13.如何开启基于注解的自动装配？要使用 @Autowired，需要注册 AutowiredAnnotationBeanPostProcessor，可以有以下两种方式来实现： 1、配置文件中的下引入 context:annotation-config 123&lt;beans&gt; &lt;context:annotation-config /&gt; &lt;/beans&gt; 2.在bean配置文件中直接引入AutowiredAnnotationBeanPostProcessor 123&lt;beans&gt; &lt;bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/&gt; &lt;/beans&gt; 14.请举例解释@Required注解？在产品级别的应用中，IoC容器可能声明了数十万了bean，bean与bean之间有着复杂的依赖关系。设值注解方法的短板之一就是验证所有的属性是否被注解是一项十分困难的操作。可以通过在中设置“dependency-check”来解决这个问题。在应用程序的生命周期中，你可能不大愿意花时间在验证所有bean的属性是否按照上下文文件正确配置。或者你宁可验证某个bean的特定属性是否被正确的设置。即使是用“dependency-check”属性也不能很好的解决这个问题，在这种情况下，你需要使用@Required 注解。需要用如下的方式使用来标明bean的设值方法。12345678910111213public class EmployeeFactoryBean extends AbstractFactoryBean&lt;Object&gt;&#123; private String designation; public String getDesignation() &#123; return designation; &#125; @Required public void setDesignation(String designation) &#123; this.designation = designation; &#125; //more code here &#125; RequiredAnnotationBeanPostProcessor是Spring中的后置处理用来验证被@Required 注解的bean属性是否被正确的设置了。在使用RequiredAnnotationBeanPostProcesso来验证bean属性之前，首先要在IoC容器中对其进行注册：1&lt;bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor" /&gt; 15.请举例说明@Qualifier注解？16.构造方法注入和设值注入有什么区别？ 在设值注入方法支持大部分的依赖注入，如果我们仅需要注入int、string和long型的变量，我们不要用设值的方法注入。对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。在构造方法注入不支持大部分的依赖注入，因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。 设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话，那么构造方法将不能覆盖由设值方法注入的值。很明显，因为构造方法尽在对象被创建时调用。 在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。 在设值注入时如果对象A和对象B互相依赖，在创建对象A时Spring会抛出sObjectCurrentlyInCreationException异常，因为在B对象被创建之前A对象是不能被创建的，反之亦然。所以Spring用设值注入的方法解决了循环依赖的问题，因对象的设值方法是在对象被创建之前被调用的。17 Spring框架中有哪些不同类型的事件？Spring的ApplicationContext 提供了支持事件和代码中监听器的功能。我们可以创建bean用来监听在ApplicationContext 中发布的事件。ApplicationEvent类和在ApplicationContext接口中处理的事件，如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。1234567public class AllApplicationEventListener implements ApplicationListener &lt; ApplicationEvent &gt;&#123; @Override public void onApplicationEvent(ApplicationEvent applicationEvent) &#123; //process event &#125; &#125; Spring 提供了以下5中标准的事件： 上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。 上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。 上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。 上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。 请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。 除了上面介绍的事件以外，还可以通过扩展ApplicationEvent 类来开发自定义的事件。 18、FileSystemResource和ClassPathResource有何区别？ 在FileSystemResource 中需要给出spring-config.xml文件在你项目中的相对路径或者绝对路径。在ClassPathResource中spring会在ClassPath中自动搜寻配置文件，所以要把ClassPathResource 文件放在ClassPath下。 如果将spring-config.xml保存在了src文件夹下的话，只需给出配置文件的名称即可，因为src文件夹是默认。简而言之，ClassPathResource在环境变量中读取配置文件，FileSystemResource在配置文件中读取配置文件。19、Spring 框架中都用到了哪些设计模式？Spring框架中使用到了大量的设计模式，下面列举了比较有代表性的： 代理模式—在AOP和remoting中被用的比较多。 单例模式—在spring配置文件中定义的bean默认为单例模式。 模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。 前端控制器—Spring提供了DispatcherServlet来对请求进行分发。 视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。 依赖注入—贯穿于BeanFactory / ApplicationContext接口的核心理念。工厂模式—BeanFactory用来创建对象的实例。]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刷题--栈和队列]]></title>
    <url>%2F2017%2F06%2F20%2F%E5%88%B7%E9%A2%98-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1.如何仅用递归函数和栈操作来逆序一个栈，不用其他数据结构123456789101112131415161718192021222324252627282930public class StackAndQueue &#123; public static void main(String[]args)&#123; Stack&lt;Integer&gt;stack=new Stack&lt;&gt;(); stack.push(1); stack.push(2); stack.push(3); System.out.print("before:"); System.out.println(stack); System.out.print("after:"); reverse(stack); System.out.println(stack); &#125; public static int getAndRemoveLastElement(Stack&lt;Integer&gt; stack)&#123; if(stack.isEmpty()) throw new RuntimeException("stack is Empty!"); int element=stack.pop(); if(stack.isEmpty())&#123; return element; &#125; int bottom=getAndRemoveLastElement(stack); stack.push(element); return bottom; &#125; public static void reverse(Stack&lt;Integer&gt; stack)&#123; if(stack.isEmpty()) return ; int bottom =getAndRemoveLastElement(stack); reverse(stack); stack.push(bottom); return ; &#125;&#125; 2.生成窗口最大值数组（page 19） 1234567891011121314151617181920212223public class GetMaxWindow &#123; public static void main(String[] args) &#123; int []arr=&#123;4,3,5,4,3,3,6,7&#125;; int []result = new GetMaxWindow().getMaxWindow(arr,3); System.out.println(Arrays.toString(result)); &#125; public int[] getMaxWindow(int[] arr, int w) &#123; if (arr == null || arr.length &lt; w || w &lt; 1) return null; LinkedList&lt;Integer&gt; qmax = new LinkedList&lt;&gt;(); int []result=new int[arr.length-w+1]; int index=0; for (int i = 0; i &lt; arr.length; i++) &#123; if (!qmax.isEmpty()&amp;&amp; i - w == qmax.getFirst()) qmax.removeFirst(); while (!qmax.isEmpty() &amp;&amp; arr[qmax.getLast()] &lt;= arr[i]) &#123; qmax.removeLast(); &#125; qmax.addLast(i); if(i+1&gt;=w) result[index++]=arr[qmax.peekFirst()]; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>数据结构及算法</category>
      </categories>
      <tags>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试问题总结]]></title>
    <url>%2F2017%2F06%2F20%2F%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.谈谈ThreadLocal？线程局部变量(ThreadLocal)就是为每一个使用该变量的线程都提供一个变量值的副本，每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。其实实现的思路很简单，在ThreadLocal类中有一个Map，用于存储每一个线程的变量的副本。同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。 深入剖析ThreadLocal 2.java内存模型Java内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步，在并发编程领域，有两个关键问题：线程之间的通信和同步。Java线程之间的通信采用的是共享内存模型，JMM决定一个线程对共享变量的写入何时对另一个线程可见。线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。 全面理解Java内存模型 JVM内存的那些事 3.聊聊JVM的体系结构？ 程序计数器：每个线程都有，是当前线程所执行的字节码的行号指示器。Java虚拟机的多线程就是通过线程轮流切换并分配处理器时间来实现的，为了线程切换后能恢复到正确的位置，每条线程都需要一个独立的程序计数器，互不影响，该区域为“线程私有”。 Java虚拟机栈：线程私有的，与线程生命周期相同，用于存储局部变量表，操作数栈、动态链接、方法返回值。局部变量表放着基本数据类型，还有对象的引用。 本地方法栈：跟虚拟机栈很像，不过它是为虚拟机使用到的Native方法服务。 Java堆：所有线程共享的一块内存区域，对象实例几乎都在这分配内存。 方法区：各个线程共享的区域，储存虚拟机加载的类信息，常量，静态变量，编译后的代码。运行时常量池是方法区的一部分，用于存放编译期间生成的各种字面常量和符号引用。 运行时常量池：代表运行时每个class文件中的常量表。包括几种常量：编译时的数字常量、方法或者域的引用。 4.谈谈Java GC是在什么时候，对什么东西，做了什么事情？虚拟机把堆内存划分成新生代（Young Generation）、老年代（Old Generation）和永久代（Permanent Generation）3个区域。新生代由 Eden 与 Survivor Space（S0，S1）构成,默认是8：1，大多数情况下，对象在Eden中分配，当Eden没有足够空间时，会触发一次Minor GC，当新生代发生GC（Minor GC）时，会将存活的对象移动到S0内存区域，并清空Eden区域，当再次发生Minor GC时，将Eden和S0中存活的对象移动到S1内存区域。存活对象会反复在S0和S1之间移动，当对象从Eden移动到Survivor或者在Survivor之间移动时，对象的GC年龄自动累加，当GC年龄超过默认阈值15时，会将该对象移动到老年代。当老年代的空间不足时，会触发Major GC/Full GC，速度一般比Minor GC慢10倍以上。 收集算法：1、标记-清除算法；2、复制算法；3、标记-整理算法；4、分代收集算法 垃圾收集器：1.Serial收集器、2.ParNew收集器、3、Parallel Scavenge收集器（并行回收GC）4、Serial Old收集器（串行GC）5、Parallel Old收集器（并行GC）6、CMS收集器（并发GC）7、G1收集器 Java GC的那些事（上） Java GC的那些事（下） 5.谈谈sychronized和Lock？ synchronized都是隐式获取和释放锁，Lock是显式的获取和释放。但是Lock比synchronized更灵活，比如，先获得锁A再获得锁B，当获得锁B时释放锁A，同时获取锁C，Lock更容易操作。 Lock多了定时锁等候和中断锁等候 ， 线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定， 如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断 ，如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情 。同样，截止时间到了仍旧无法获取锁，则返回。 synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异 常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到 finally{}中。 在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String中的intern方法]]></title>
    <url>%2F2017%2F05%2F08%2FString%E4%B8%AD%E7%9A%84intern%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[首先先提出一个问题，String str=new String(“abc”);这行代码究竟创建了几个String对象呢？答案是2个，一个存放在堆中，一个存放在字符串常量池中。String a=”abc”; String b=”abc”;那这里呢？答案是一个，因为是从常量池中获取的同一个对象String a=”ab”+”cd”;再看看这里呢？创建了3个对象，分别是“ab”，”cd”和“abcd” 我们再回头看看String a=”abc”;，这行代码被执行的时候，JAVA虚拟机首先在字符串池中查找是否已经存在了值为”abc”的这么一个对象，它的判断依据是String类equals(Object obj)方法的返回值。如果有，则不再创建新的对象，直接返回已存在对象的引用；如果没有，则先创建这个对象，然后把它加入到字符串池中，再将它的引用返回。因此，我们不难理解前面三个例子中头两个例子为什么是这个答案了。只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中，因此我们提倡大家用引号包含文本的方式来创建String对象以提高效率，实际上这也是我们在编程中常采用的。例如：String s3 = new String(“1”) + new String(“1”);其产生4个对象，撇去两个匿名对象不作讨论，剩下两个一个是常量池中的“1”，还有一个堆中的new String(“11”)对象，注意常量池中并没有”11”下面来看一段代码： 1234567891011public static void main(String[] args) &#123;//jdk7中运行 String s = new String("1"); s.intern(); String s2 = "1"; System.out.println(s == s2);//false,s指向堆中，s2指向常量池 String s3 = new String("1") + new String("1"); s3.intern();//常量池中生成了一个指向堆的引用（并不是复制对象到常量池中了） String s4 = "11"; System.out.println(s3 == s4);//true&#125; 然后将s3.intern(); 语句下调一行:1234567891011public static void main(String[] args) &#123; String s = new String("1"); String s2 = "1"; s.intern(); System.out.println(s == s2);//false String s3 = new String("1") + new String("1");//此时常量池中并没有“11” String s4 = "11"; s3.intern();//此时常量池已经有"11"了，故此句返回是s4，并不是指向s3 System.out.println(s3 == s4);//false&#125; 注：String.intern() 在常量池中存在该对象，则返回，如不存在则会直接保存对象的引用，而不会重新创建对象。同样的道理：1234String str1=new StringBuilder("计算机").toString();//创建了两个对象，一个堆中，一个常量池中System.out.println(str1.intern()==str1);//false，因为str1.intern()指向的是常量池中的对象String str2=new StringBuilder("计算机").append("软件").toString();//常量池中并没有"计算机软件"System.out.println(str2.intern()==str2);//true，常量池中存储堆中的引用。这份引用指向str2引用的对象 注：读《深入理解java虚拟机》p57之后学习了本知识点]]></content>
      <categories>
        <category>JAVA语言</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何求解中缀表达式]]></title>
    <url>%2F2017%2F04%2F26%2F%E5%A6%82%E4%BD%95%E6%B1%82%E8%A7%A3%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[中缀表达式: 即我们常看到的表达式如3+2*(4+6)+5，但是对于计算机而言处理中缀表达式要比处理后缀表达式困难的多,那何为后缀表达式呢？后缀表达式: 如上面的中缀表达式转换成后缀表达式即为:3246+*+5 ,可以看到去除了中缀表达式的括号，因为计算的优先级在式中已经体现出来。处理过程: 遍历后缀表达式这个式子，遇到数字就放入栈中，遇到符号则弹出栈顶的两个元素进行计算，计算结果再push到栈中，以此类推到最后一次运算后，栈中只有一个元素，这个就是最后表达式求出来的值。那现在如何将中缀表达式转换成后缀表达式呢？算法思路： s1：初始化一个空栈(stack)记录读取到的操作符,一个StringBuilder对象(stringbuilder)存放后缀表达式 s2:从左到右遍历输入表达式,每次一个字符 s3:若读取到数字,追加至stringBuilder末尾 若读取到左括号’(‘, 则将’(‘入栈,若读取到右括号’)’, 则操作符依次出栈追加至stringBuilder末尾,知道遇到一个左括号,该左括号直接出栈 若读取到的运算符, 优先级小于等于栈顶运算符（‘+’小于‘* ’），则栈中运算符依次出栈追加到stringBuilder尾部直到读取的运算符优先级比栈顶的运算符要大或者栈顶运算符是’(‘，之后将该运算符入栈。 遍历结束后，若栈中还有运算符则依次出栈追加至stringBuilder末尾 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class Test &#123; public static void main(String[]args)&#123; String expressionStrs="3+2-1+2*(3+2)-4/2"; String suffixExpression=toSuffixExpression(expressionStrs); System.out.println(suffixExpression); System.out.println(calculateExpression(suffixExpression)); &#125; public static double calculateExpression(String suffixExpression)&#123; Stack&lt;Double&gt; stack=new Stack&lt;&gt;();//运算栈 for(int i=0;i&lt;suffixExpression.length();i++)&#123; if('+'==suffixExpression.charAt(i))&#123; double num2=stack.pop(); double num1=stack.pop(); stack.push(num1+num2); &#125;else if('-'==suffixExpression.charAt(i))&#123; double num2=stack.pop(); double num1=stack.pop(); stack.push(num1-num2); &#125;else if('*'==suffixExpression.charAt(i))&#123; double num2=stack.pop(); double num1=stack.pop(); stack.push(num1*num2); &#125;else if('/'==suffixExpression.charAt(i))&#123; double num2=stack.pop(); double num1=stack.pop(); stack.push(num1/num2); &#125;else&#123; stack.push((double)(suffixExpression.charAt(i)-'0'));//将字符转换成double &#125; &#125; return stack.pop(); &#125; public static String toSuffixExpression(String expressionStrs) &#123; StringBuilder newExpressionStrs = new StringBuilder();//转换后的后缀表达式 Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();//存放运算符 for (int i = 0; i &lt; expressionStrs.length(); i++) &#123; if('('==expressionStrs.charAt(i))&#123; stack.push(expressionStrs.charAt(i)); &#125; else if('+'==expressionStrs.charAt(i) || '-'==expressionStrs.charAt(i) || '*'==expressionStrs.charAt(i) || '/'==expressionStrs.charAt(i)) &#123; while(!stack.isEmpty() &amp;&amp; //判断优先级 isNotPrior(expressionStrs.charAt(i),stack.peek()))&#123; newExpressionStrs.append(stack.pop()); &#125; stack.add(expressionStrs.charAt(i));//讲当前运算符加入栈中 &#125; else if(')'==expressionStrs.charAt(i))&#123; while('('!=stack.peek())&#123; newExpressionStrs.append(stack.pop());//'('之前的所有运算符都添加到后缀表达式尾部 &#125; stack.pop();//'('出栈 &#125; else&#123; newExpressionStrs.append(expressionStrs.charAt(i));//数字都直接添加 &#125; &#125; while (!stack.isEmpty())&#123;//注意遍历完成后栈中所有的运算符全部出栈 newExpressionStrs.append(stack.pop()); &#125; return newExpressionStrs.toString(); &#125; public static boolean isNotPrior(char ch1,char ch2)&#123;//判断优先级 if('('==ch2)&#123; return false;//遇到'('就不能出栈了，并不代表优先级 &#125; if(('*'==ch1||'/'==ch1 )&amp;&amp; ('+'==ch2||'-'==ch2))&#123; return false; &#125; return true; &#125;&#125; 计算结果： 32+1-232++42/- * 12.0 PS:本算法不支持多位数的运算]]></content>
      <categories>
        <category>数据结构及算法</category>
      </categories>
      <tags>
        <tag>中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tree]]></title>
    <url>%2F2017%2F04%2F25%2FTree%2F</url>
    <content type="text"><![CDATA[1.Given a binary tree, find its maximum depth.The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.(求二叉树的最大深度)way1: 层次遍历–&gt;每进一层加1 1234567891011121314151617181920212223242526272829/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */import java.util.*;public class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root==null) return 0; int depth=0; LinkedList&lt;TreeNode&gt; list=new LinkedList&lt;&gt;(); list.add(root); while(!list.isEmpty())&#123; depth++; int len=list.size(); for(int i=0;i&lt;len;i++)&#123; TreeNode temp=list.poll(); if(temp.left!=null) list.add(temp.left); if(temp.right!=null) list.add(temp.right); &#125; &#125; return depth; &#125;&#125; way2: 递归实现，一颗二叉树的深度就是其左子树深度和右子树深度较大的一方加1123456public int maxDepth(TreeNode root) &#123; if(root==null) return 0; int lDepth= maxDepth(root.left); int rDepth= maxDepth(root.right); return 1+(lDepth&gt;rDepth?lDepth:rDepth);&#125; 2.Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. (求二叉树的最小深度)123456789101112public int run(TreeNode root) &#123; if(root==null) return 0; int leftChildTreeMinimuDepth=run(root.left); int rightChildTreeMinimuDepth=run(root.right); if(leftChildTreeMinimuDepth==0||rightChildTreeMinimuDepth==0) return leftChildTreeMinimuDepth+rightChildTreeMinimuDepth+1; return 1+(leftChildTreeMinimuDepth&lt;rightChildTreeMinimuDepth? leftChildTreeMinimuDepth:rightChildTreeMinimuDepth); &#125; 3.用迭代的方法求二叉树的前、中、后序遍历 前序遍历 1234567891011121314public ArrayList&lt;Integer&gt; preOrderTraversal2(TreeNode root) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if (root == null) return list; stack.push(root); while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); list.add(node.val); if (node.right != null) stack.push(node.right); if (node.left != null) stack.push(node.left); &#125; return list; &#125; 中序遍历 12345678910111213141516public static ArrayList&lt;Integer&gt; inOrderTraversal2(TreeNode root)&#123; ArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); if(root==null) return list; TreeNode runNode=root; while(!stack.isEmpty()||runNode!=null)&#123; while(runNode!=null)&#123; stack.push(runNode); runNode=runNode.left; &#125; TreeNode node=stack.pop(); list.add(node.val); runNode=node.right; &#125; return list; &#125; 后序遍历 12345678910111213public static ArrayList&lt;Integer&gt; postorderTraversal2(TreeNode root) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if (root == null) return list; stack.push(root); while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); list.add(0, node.val); if (node.left != null) stack.push(node.left); if (node.right != null) stack.push(node.right); &#125; return list; &#125; 4.Given a binary tree containing digits from0-9only, each root-to-leaf path could represent a number.An example is the root-to-leaf path1-&gt;2-&gt;3which represents the number123.Find the total sum of all root-to-leaf numbers.For example,The root-to-leaf path1-&gt;2represents the number12.The root-to-leaf path1-&gt;3represents the number13.Return the sum = 12 + 13 =25.(求根节点到叶节点所有路径和)way1，前序遍历的思路，显得臃肿12345678910111213141516171819public class Solution &#123; StringBuilder sb=new StringBuilder(); int sum; public int sumNumbers(TreeNode root) &#123; preOrderTraversal(root); return sum; &#125; public void preOrderTraversal(TreeNode root)&#123; if(root ==null) return; sb.append(root.val); if(root.left==null &amp;&amp; root.right==null)&#123; sum+=Integer.parseInt(sb.toString()); &#125; preOrderTraversal(root.left); preOrderTraversal(root.right); sb.deleteCharAt(sb.length()-1); &#125;&#125; way2，利用数值特性，简单高效123456789101112public class Solution &#123; public int sumNumbers(TreeNode root) &#123; int sum=0; return sumNumbers2(root,sum); &#125; public static int sumNumbers2(TreeNode root,int sum)&#123; if(root==null) return 0; sum=sum*10+root.val; if(root.left==null &amp;&amp; root.right==null) return sum; return sumNumbers2(root.left,sum)+sumNumbers2(root.right,sum); &#125;&#125; 同理：求根到叶的所有路径 1234567891011121314public class Test &#123; public static ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;(); public static StringBuilder sb=new StringBuilder(); public static void rootToLeafPath(TreeNode root)&#123; if(root==null) return ; sb.append(root.val); if(root.left==null &amp;&amp; root.right==null)&#123; list.add(sb.toString()); &#125; rootToLeafPath(root.left); rootToLeafPath(root.right); sb.deleteCharAt(sb.length()-1);//手动去除已经访问过的结点 &#125;&#125; 5.Follow up for problem “Populating Next Right Pointers in Each Node”.What if the given tree could be any binary tree? Would your previous solution still work?(将每个结点的next指针指向右兄弟结点，如没有则指向null)123456789101112131415public void connect(TreeLinkNode root) &#123; Queue&lt;TreeLinkNode&gt; queue=new LinkedList&lt;&gt;(); if(root==null) return ; queue.add(root); while(!queue.isEmpty())&#123;//层序遍历思想 int layerSize=queue.size(); while(layerSize--!=0)&#123; TreeLinkNode node=queue.poll(); if(layerSize!=0) node.next=queue.peek(); else node.next=null; if(node.left!=null) queue.add(node.left); if(node.right!=null) queue.add(node.right); &#125; &#125; &#125; 6.Given a binary tree, find the maximum path sum.The path may start and end at any node in the tree.(在二叉树中找一条路径，使得该路径的和最大。该路径可以从二叉树任何结点开始，也可以到任何结点结束。)思路：递归求一条经过root的最大路径，这条路径可能是： 左边某条路径 + root + 右边某条路径 左边某条路径 + root root + 右边某条路径 root 123456789101112131415public class Solution&#123; public int max=Integer.MIN_VALUE; public int maxPathSum(TreeNode root) &#123; maxPathSumFromRoot(root); return max; &#125; public int maxPathSumFromRoot(TreeNode root)&#123; if(root==null) return 0; int leftMaxSum=Math.max(maxPathSumFromRoot(root.left),0);//如果其左子树的最大和小于0 int rightMaxSum=Math.max(maxPathSumFromRoot(root.right),0);//，该子树就是废树，没贡献，就视作没有吧 int curMax=root.val+leftMaxSum+rightMaxSum;//当前一棵树上的最大和 if(curMax&gt;max) max=curMax; return Math.max(root.val+leftMaxSum,root.val+rightMaxSum);//返回经过该根结点的最大和 &#125;&#125; 附加1：求根结点到叶结点路径和的最大值12345678public int maxSumFromRootToLeaf(TreeNode root)&#123; if(root==null) return 0; int leftMaxSum=maxSumFromRootToLeaf(root.left); int rightMaxSum=maxSumFromRootToLeaf(root.right); if(root.left==null) return root.val+rightMaxSum; if(root.right==null) return root.val+leftMaxSum; return root.val+(leftMaxSum&gt;rightMaxSum?leftMaxSum:rightMaxSum); &#125; 7.Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.求出根结点到叶结点的和为sum的所有路径1234567891011121314151617181920212223public class Solution &#123; public ArrayList&lt;Integer&gt; path=new ArrayList&lt;&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; paths=new ArrayList&lt;&gt;(); public int curSum; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; preTraversal(root,sum); return paths; &#125; public void preTraversal(TreeNode root,int sum)&#123; if(root==null) return; path.add(root.val); curSum+=root.val; if(root.left==null&amp;&amp; root.right==null)&#123; if(curSum==sum)&#123; paths.add(new ArrayList&lt;Integer&gt;(path)); &#125; &#125; preTraversal(root.left,sum); preTraversal(root.right,sum); curSum-=root.val; path.remove(path.size()-1); &#125;&#125; 8.Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.For example: Given the below binary tree and sum = 22(判断根结点到叶结点的和是否为指定sum) 常规解法 123456789101112131415161718public class Solution &#123; public int curSum; public boolean hasPathSum=false; public boolean hasPathSum(TreeNode root, int sum) &#123; preTraversal(root,sum); return hasPathSum; &#125; public void preTraversal(TreeNode root ,int sum)&#123; if(root==null) return ; curSum+=root.val; if(root.left==null &amp;&amp; root.right==null)&#123; if(curSum==sum) hasPathSum=true; &#125; preTraversal(root.left,sum); preTraversal(root.right,sum); curSum-=root.val; &#125;&#125; 递归方法（推荐） 123456public boolean hasPathSum(TreeNode root, int sum) &#123; if(root==null) return false; if(root.left==null &amp;&amp; root.right==null) return root.val==sum; return hasPathSum(root.left,sum-root.val) ||hasPathSum(root.right,sum-root.val);&#125; 9.Given a binary tree, determine if it is height-balanced.For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 平衡树：其左右子树的深度差不大于1，而且左右子树也是平衡树。1234567891011public boolean isBalanced(TreeNode root) &#123; if(root==null) return true; int leftDepth=TreeDepth(root.left); int rightDepth=TreeDepth(root.right); if(Math.abs(leftDepth-rightDepth)&gt;1) return false; return isBalanced(root.left)&amp;&amp;isBalanced(root.right); &#125; public int TreeDepth(TreeNode root)&#123;//求树的深度 if(root==null) return 0; return Math.max(TreeDepth(root.left),TreeDepth(root.right))+1; &#125; 10.Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).(层序遍历从左到右，由底至顶！)123456789101112131415161718public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result=new ArrayList&lt;&gt;(); LinkedList&lt;TreeNode&gt; list=new LinkedList&lt;&gt;(); if(root==null) return result; list.add(root); while(!list.isEmpty())&#123; int len=list.size(); ArrayList&lt;Integer&gt; level=new ArrayList&lt;&gt;(); while(len--!=0)&#123; TreeNode temp=list.poll(); level.add(temp.val); if(temp.left!=null) list.add(temp.left); if(temp.right!=null) list.add(temp.right); &#125; result.add(0,new ArrayList&lt;Integer&gt;(level)); &#125; return result; &#125; 11.Given inorder and postorder traversal of a tree, construct the binary tree.(根据中序遍历和后序遍历的结果构造树)123456789101112131415161718public TreeNode buildTree(int[] inorder, int[] postorder) &#123; int instart=0,inEnd=inorder.length-1; int postStart=0,postEnd=postorder.length-1; return buildTreeProcess(inorder,instart,inEnd,postorder,postStart,postEnd); &#125; public TreeNode buildTreeProcess(int[]inOrder,int inStart,int inEnd, int[]postOrder,int postStart,int postEnd)&#123; if(inStart&gt;inEnd) return null; if(inStart==inEnd) return new TreeNode(inOrder[inStart]); TreeNode node=new TreeNode(postOrder[postEnd]); int i=inStart,target=postOrder[postEnd]; while(inOrder[i]!=target) i++; node.left=buildTreeProcess(inOrder,inStart,i-1, postOrder,postStart,postStart+i-1-inStart); node.right=buildTreeProcess(inOrder,i+1,inEnd, postOrder,postStart+i-inStart,postEnd-1); return node; &#125; 12.Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).（拉链层序遍历）123456789101112131415161718192021public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); if (root == null) return result; queue.add(root); boolean flag = true; while (!queue.isEmpty()) &#123; ArrayList&lt;Integer&gt; level = new ArrayList&lt;&gt;(); int len = queue.size(); for (int i = 0; i &lt; len; i++) &#123; TreeNode temp = queue.poll(); if(flag) level.add(temp.val); else level.add(0,temp.val); if (temp.left != null) queue.add(temp.left); if (temp.right != null) queue.add(temp.right); &#125; flag=!flag; result.add(level); &#125; return result; &#125; 13.Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).(层序遍历)123456789101112131415161718public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result=new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue=new LinkedList&lt;&gt;(); if(root==null) return result; queue.add(root); while(!queue.isEmpty())&#123; ArrayList&lt;Integer&gt; level=new ArrayList&lt;&gt;(); int len=queue.size(); while(len--!=0)&#123; TreeNode temp=queue.poll(); level.add(temp.val); if(temp.left!=null) queue.add(temp.left); if(temp.right!=null) queue.add(temp.right); &#125; result.add(level); &#125; return result; &#125; 14.Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).(判断一棵树是否对称) 递归方法： 1234567891011public boolean isSymmetric(TreeNode root) &#123; if(root==null) return true; return isSymmetric(root.left,root.right);&#125;public boolean isSymmetric(TreeNode left,TreeNode right)&#123; if(left==null&amp;&amp; right==null) return true; if(left!=null &amp;&amp; right!=null) return left.val==right.val &amp;&amp; isSymmetric(left.left,right.right) &amp;&amp; isSymmetric(left.right,right.left); return false;&#125; 迭代方法: 1234567891011121314151617public boolean isSymmetric(TreeNode root) &#123; if(root==null) return true; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); stack.push(root.left); stack.push(root.right); while(!stack.isEmpty())&#123; TreeNode node1=stack.pop(); TreeNode node2=stack.pop(); if(node1==null &amp;&amp; node2==null) continue; if(node1==null||node2==null||node1.val!=node2.val) return false; stack.push(node1.left); stack.push(node2.right); stack.push(node1.right); stack.push(node2.left); &#125; return true; &#125; 15.Given two binary trees, write a function to check if they are equal or not.Two binary trees are considered equal if they are structurally identical and the nodes have the same value.(判断两棵树是否相等)12345public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p==null &amp;&amp; q==null) return true; if(p==null||q==null) return false; return p.val==q.val&amp;&amp;isSameTree(p.left,q.left)&amp;&amp;isSameTree(p.right,q.right);&#125; 16.Two elements of a binary search tree (BST) are swapped by mistake.Recover the tree without changing its structure.思路：直观的想法可能是中序遍历一遍二叉树，得到一个有序的二叉树，然后找出其中逆序的地方，交换回来就好了。但这样空间复杂度就是O(n)，题目要求O(1)。我们来分析下有哪些情况：1) 被交换的两个结点相邻，如124356，这样只需要把相邻的3和4交换回来即可；2) 被交换的两个结点不相邻，如163452，这样我们需要找出两个逆序的地方，63和52，并交换第一个逆序的前者和第二个逆序的后者。我们如何做到一次DFS即可找出两个结点呢，并且空间为O(1)，用p和q两个指针存放要交换的两个结点是必要的，还需要一个pre指针在DFS过程中标记当前结点的前一个结点，以判断前后是否为逆序关系。当第一次找到逆序时，如43，把p=3，q=4，如果后面没有发现第二个逆序，那么最后交换p和q即可。如果有两个逆序，如63和52，当我们发现第一个逆序63时，把p=6，q=3，然后发现第二个逆序52时，把q=2，最后交换p和q。12345678910111213141516171819public class Solution &#123; TreeNode pre,mistake1,mistake2; public void recoverTree(TreeNode root) &#123; inTraversal(root); mistake1.val=mistake2.val^mistake1.val^(mistake2.val=mistake1.val);//一句代码解决两个数的交换 &#125; public void inTraversal(TreeNode root)&#123; if(root==null) return ; inTraversal(root.left); if(pre!=null&amp;&amp;pre.val&gt;root.val)&#123; if(mistake1==null)&#123; mistake1=pre; mistake2=root; &#125;else mistake2=root; &#125; pre=root; inTraversal(root.right); &#125;&#125; 17.Given a binary tree, determine if it is a valid binary search tree (BST).Assume a BST is defined as follows:The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than the node’s key.Both the left and right subtrees must also be binary search trees.（判断一棵树是不是二叉搜索树） 思路1：递归法，条件，其左右子树是二叉搜索树，而且root的值大于左子树最大的值，小于右子树最小的值。 123456789101112public boolean isValidBST(TreeNode root) &#123; if(root==null)return true; if(root.left==null &amp;&amp;root.right==null) return true; TreeNode left=(root.left==null?null:root.left); while(left!=null&amp;&amp;left.right!=null) left=left.right; TreeNode right=(root.right==null?null:root.right); while(right!=null&amp;&amp;right.left!=null) right=right.left; return (left==null?true:root.val&gt;left.val) &amp;&amp; (right==null?true:root.val&lt;right.val) &amp;&amp;isValidBST(root.left) &amp;&amp; isValidBST(root.right);&#125; 思路2：递归法（简单）每个结点都有一个上限，一个下限。(推荐) 123456789public boolean isValidBST(TreeNode root) &#123; return isValidRoot(root,Integer.MIN_VALUE,Integer.MAX_VALUE);&#125;public boolean isValidRoot(TreeNode root,int lower,int upper)&#123; if(root==null) return true; if(root.val&lt;=lower || root.val&gt;=upper) return false; return isValidRoot(root.left,lower,root.val) &amp;&amp; isValidRoot(root.right,root.val,upper);&#125; 思路3：中序遍历，记录前一个结点，跟当前结点比较 123456789101112131415public class Solution &#123; TreeNode pre; boolean isValidBST=true; public boolean isValidBST(TreeNode root) &#123; inTraversal(root); return isValidBST; &#125; public void inTraversal (TreeNode root)&#123; if(root==null) return ; inTraversal(root.left); if(pre!=null&amp;&amp;pre.val&gt;=root.val) isValidBST=false; pre=root; inTraversal(root.right); &#125;&#125;]]></content>
      <categories>
        <category>数据结构及算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A story of Unicode and UTF-8]]></title>
    <url>%2F2017%2F04%2F22%2FA-story-of-Unicode-and-UTF-8%2F</url>
    <content type="text"><![CDATA[很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为”字节“。再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机“。 开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。 他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上0×10, 终端就换行，遇上0×07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0×20以下的字节状态称为”控制码”。他们又把所有的空 格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉 很好，于是大家都把这个方案叫做 ANSI 的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。 后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机 保存他们的文字，他们决定采用 127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128 到255这一页的字符集被称”扩展字符集“。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！ 等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气 地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的 字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 中国人民看到这样很不错，于是就把这种汉字方案叫做 “GB2312“。GB2312 是对 ASCII 的中文扩展。 但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。 后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字 符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK包括了GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。 后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS“（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处 理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣 们都要每天念下面这个咒语数百遍： “一个汉字算两个英文字符！一个汉字算两个英文字符……” 因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海 里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序 就必须加装另一套支持 BIG5 编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎 么办？ 真是计算机的巴比伦塔命题啊！ 正在这时，大天使加百列及时出现了——一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号 的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “unicode“。 unicode开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ASCII里的那些“半角”字符，unicode包持其原编码不变，只是将其长度由原 来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在 保存英文文本时会多浪费一倍的空间。 这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是的，从unicode开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的”一个字符“！同时，也都是统一的”两个字节“，请注意”字符”和”字节”两个术语的不同，“字节”是一个8位的物理存贮单元，而“字符”则是一个文化相关的符号。在unicode中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。 unicode同样也不完美，这里就有两个的问题，一个是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是 分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每 个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费，文本文件的大小会因此大出二三倍，这是难以接受的。 unicode在很长一段时间内无法推广，直到互联网的出现，为解决unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。UTF-8就是在互联网上使用最广的一种unicode的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。 UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII 码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中 文字符占3个字节）。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。 Unicode符号范围 | UTF-8编码方式 (十六进制) | （二进制）—————————————————————–0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 参考]]></content>
      <categories>
        <category>CS基础</category>
      </categories>
      <tags>
        <tag>编码</tag>
        <tag>utf—8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F04%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
