<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java8特性]]></title>
    <url>%2F2018%2F12%2F07%2Fjava8%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[一.为什么要学java8？ 代码表达能力更强，风格更简约。比如：对一个仓库里的苹果按重量进行排序，java8之前的代码可能是这样 12345Collections.sort(inventory, new Comparator&lt;Apple&gt;() &#123; public int compare(Apple a1, Apple a2)&#123; return a1.getWeight().compareTo(a2.getWeight()); &#125;&#125;); 而在java8里是这样的 1inventory.sort(comparing(Apple::getWeight)); 很明显，后者代码表达的更准确，以后也更容易维护。这种将函数传递给方法的方式，我们称之为函数式编程，也叫行为参数化，用更高级的一种方式来表达我们想要的东西。 代码效率更高、支持安全的并行执行。java8里的流实现并行，要比现有的有关线程安全的api实现的更容易。但是你的代码行为必须能够同时的对不同的输入安全的执行。 二.开始函数式编程之路小明是一个水果贩子，手里拿着一个List&lt;Apple&gt; inventory,客户想要这里面所有的绿苹果，而小明可能会实现如下代码： 123456789public static List&lt;Apple&gt; filterGreenApples(List&lt;Apple&gt; inventory) &#123; List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;(); for(Apple apple: inventory)&#123; //累积苹果的列表 if( "green".equals(apple.getColor() ) &#123; result.add(apple); //仅仅选出绿苹果 &#125; &#125; return result;&#125; 这是最直觉的思考方式下的结果，可当小明把全部的绿苹果打包完毕后，客户突然冒出一句，“红苹果也不错，我还是要所有的红苹果吧?”，小明气不打一处来，把上面的”green”换成”red”之后，当天晚上就加班搞了另外一个方法，才安然入睡 123456789public static List&lt;Apple&gt; filterApplesByColor(List&lt;Apple&gt; inventory, String color) &#123; List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;(); for (Apple apple : inventory) &#123; if (apple.getColor().equals(color)) &#123; result.add(apple); &#125; &#125; return result; &#125; 但是，突然有一天，小明又接到一个电话，对方说要3两以上的苹果，机智的小明实现了如下代码: 123456789public static List&lt;Apple&gt; filterApplesByWeight(List&lt;Apple&gt; inventory, int weight) &#123; List&lt;Apple&gt; result = new ArrayList&lt;Apple&gt;(); For(Apple apple:inventory)&#123; if (apple.getWeight() &gt; weight) &#123; result.add(apple); &#125; &#125; return result; &#125; 但是小明发现，每次客户变化一个需求，就要重新搞一套方法，而且这里面的方法好多代码都是重复的，除了if里面的判断语句不一样而已。而且为了筛选苹果的方法和具体的筛选条件进行解耦，小明写了个接口，以后再有具体的筛选条件，就实现这个接口就可以了。如下 1234567891011121314public interface ApplePredicate &#123; boolean test(Apple apple); &#125;public class AppleHeavyWeightPredicate implements ApplePredicate &#123; public boolean test(Apple apple) &#123; return apple.getWeight() &gt; 150; &#125; &#125;public class AppleGreenColorPredicate implements ApplePredicate &#123; public boolean test(Apple apple) &#123; return "green".equals(apple.getColor()); &#125; &#125; 之后小明的挑选苹果的方法编程如下代码 123456789public static List&lt;Apple&gt; filterApples(List&lt;Apple&gt; inventory, ApplePredicate p) &#123; List&lt;Apple&gt; result = new ArrayList&lt;&gt;(); for (Apple apple : inventory) &#123; if (p.test(apple)) &#123; result.add(apple); &#125; &#125; return result; &#125; 从此以后，挑选苹果的方法和挑选苹果的条件就实现了解耦。小明松了一口气，对外宣称这就是我们的『行为参数化』，你看多方便，客户来一个条件，我就按照这个条件实现ApplePredicate接口，在里面写具体的业务逻辑，但是，随着客户的需求不断增多，小明发现，每次都需要新建一个类来包裹那里面一个test方法，说到底，不就是要一个test方法么。有没有更简单的方法呢？突然小明脑海中闪现出一个名词:匿名内部类 12345List&lt;Apple&gt; redApples = filterApples(inventory, new ApplePredicate() &#123; public boolean test(Apple apple) &#123; return "red".equals(apple.getColor()); &#125; &#125;); 就在小明用匿名内部类来传递自己筛选苹果的条件代码，用的热火朝天之际，java8的Lambda表达式突然宣告诞生，小明欣喜的跟上了时代的步伐: 1List&lt;Apple&gt; result = filterApples(inventory, (Apple apple) -&gt; "red".equals(apple.getColor())); 他突然感悟到所谓的大道至简是有点道理的。随着小明卖苹果的技术越来越精湛、效率越来越高，很快也开始主营卖香蕉、菠萝，聪明的小明一下子就明白，把原来的卖苹果那一套进一步抽象，适合卖所有的水果: 123456789101112public interface Predicate&lt;T&gt; &#123; boolean test(T t); &#125;public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p) &#123; List&lt;T&gt; result = new ArrayList&lt;&gt;(); for (T e : list) &#123; if (p.test(e)) &#123; result.add(e); &#125; &#125; return result;&#125; 这样，小明平常就是这样经营他的水果摊的 12List&lt;Apple&gt; redApples = filter(inventory, (Apple apple) -&gt; "red".equals(apple.getColor()));List&lt;Orange&gt; heavyOranges=filter(inventory,(Orange o)-&gt; o.getWeight&gt;30); 这里Predicate，可以称之为函数式接口，其实它已经存在于java.util.function包中了。以后可以直接拿来用，爽歪歪有木有？只要该接口只包含一个抽象方法即可。函数式接口可以方便你写出Lambda表达式 下图为java8中典型的函数式接口]]></content>
  </entry>
  <entry>
    <title><![CDATA[刷题--栈和队列]]></title>
    <url>%2F2017%2F06%2F20%2F%E5%88%B7%E9%A2%98-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1.如何仅用递归函数和栈操作来逆序一个栈，不用其他数据结构123456789101112131415161718192021222324252627282930public class StackAndQueue &#123; public static void main(String[]args)&#123; Stack&lt;Integer&gt;stack=new Stack&lt;&gt;(); stack.push(1); stack.push(2); stack.push(3); System.out.print("before:"); System.out.println(stack); System.out.print("after:"); reverse(stack); System.out.println(stack); &#125; public static int getAndRemoveLastElement(Stack&lt;Integer&gt; stack)&#123; if(stack.isEmpty()) throw new RuntimeException("stack is Empty!"); int element=stack.pop(); if(stack.isEmpty())&#123; return element; &#125; int bottom=getAndRemoveLastElement(stack); stack.push(element); return bottom; &#125; public static void reverse(Stack&lt;Integer&gt; stack)&#123; if(stack.isEmpty()) return ; int bottom =getAndRemoveLastElement(stack); reverse(stack); stack.push(bottom); return ; &#125;&#125; 2.生成窗口最大值数组（page 19） 1234567891011121314151617181920212223public class GetMaxWindow &#123; public static void main(String[] args) &#123; int []arr=&#123;4,3,5,4,3,3,6,7&#125;; int []result = new GetMaxWindow().getMaxWindow(arr,3); System.out.println(Arrays.toString(result)); &#125; public int[] getMaxWindow(int[] arr, int w) &#123; if (arr == null || arr.length &lt; w || w &lt; 1) return null; LinkedList&lt;Integer&gt; qmax = new LinkedList&lt;&gt;(); int []result=new int[arr.length-w+1]; int index=0; for (int i = 0; i &lt; arr.length; i++) &#123; if (!qmax.isEmpty()&amp;&amp; i - w == qmax.getFirst()) qmax.removeFirst(); while (!qmax.isEmpty() &amp;&amp; arr[qmax.getLast()] &lt;= arr[i]) &#123; qmax.removeLast(); &#125; qmax.addLast(i); if(i+1&gt;=w) result[index++]=arr[qmax.peekFirst()]; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F04%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
